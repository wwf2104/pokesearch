1. Database is on jj2882 account

2. 104.196.209.24:8111

3. Most parts of our original proposal in Part 1 were implemented. For example, we have entity sets such as pokemon, moves, items, and etc. We also have all relationship sets from the initial proposal, such as can_find, can_learn, found_in, and etc. There is one thing that we did not implement, which is an attribute "likelihood" of the relationship set found_in. The likelihood values are coming from Bulbapedia's location pages which are separate from the website's pokemon pages. We were able to web-scrape the pokemon pages using the BeautifulSoup library of Python. However, the structures of the location pages were much more complicated, and we had a difficult time web-scraping them. We realized that the attribute likelihood is a minor feature of our databases, and deleting it does not affect the overall quality of the databases.

4. The main page is where the user can input their search requests in order to find entities that fit the request(s). They can toggle between the simple search which is based on the names of the entities and the advanced search which is based on an entity's attributes. Once they click on the 'find' button, these are sent to the corresponding simple/advanced find functions. The form inputs will be retrieved and the queries are rendered through jinja templates. While the simple find function is fairly straightforward, the advanced find function requires many templates in order to ensure that a user can search for more than more feature at a time within an entity. This is one of the more interesting pages because it can require many nested templates/queries in order to retrieve results.
Another interesting page is the results page in which the results are printed within a table. This relies on understanding the structure in which the results are retrieved from the previous query/queries and using nested for loops to create the correct <tr> and <td> tags. The reordering function essentially acts as the 'ORDER BY' statement within a sql statement through a javascript function and reorders the table without the user needing to refresh the page.